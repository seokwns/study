## 프로그래밍 언어의 역할
- 사람과 기계와의 의사소통 : 알고리즘이나 자료 구조를 표현하는 방법 = 프로그래밍 언어
- 사람과 사람과의 의사사통을 위한 매개체 역할

<br/><br/><br/>

## 읽기와 쓰기
#### 프로그래밍 숙련도
- 프로그래밍은 ‘쓰기’가 강조되는 분야
- ‘읽기’도 무시 불가. 이해하기 쉽게 코드를 작성해야 좋은 개발자이다.

#### 가독성(readability)의 중요성
- “read easily and understood by people"

<br/><br/><br/>

## 프로그래밍 언어를 학습하는 이유
1. 효과적인 알고리즘 개발
2. 더 잘 이해하여 효과적 사용
 언어에 대한 이해도가 높아져 프로그램 작성 능력 증가
 예를 들어 ```i = i + 1``` / ```i++``` 둘 다 같은 기능을 하지만 후자가 더 빠름
3. 유용한 프로그래밍 요소 활용 가능
4. 프로그램 특성에 맞는 언어 선택
5. 새로운 언어를 쉽게 배우기 위해
 프로그래밍 언어들은 많은 유사점 존재
6. 새로운 언어를 쉽게 설계하기 위해

<br/><br/><br/>

## 프로그래밍 언어의 분류
### 문제 영역 (Problem Domain)
- 사무용, 과학계산, 시스템 프로그래밍, 인공지능, 웹과 같이 분야에 따라 나누기

### 패러다임
패러다임 = 프로그래밍 스타일 이다.
- 절차 언어
- 함수형 언어
- 모듈 기반 언어
- 객체 지향 언어
- generic 프로그래밍
- 룰 기반 언어

### 계산 모델 (Computational Model)
- 명령형 언어 : 폰 노이만 구조 기반
- 함수형 언어 : 순환 함수 이론 기반
- 논리 언어 : 수학적 논리(연역 논리) 기반

<br/><br/><br/>

## 프로그래밍 언어의 목표 변천사
초창기기인 1950~60년대는 언어와 하드웨어 밀착 시기여서 goto문을 사용하고 컴퓨터 값이 고가이므로 수행 효율이 매우 중요했습니다.

#### 일괄처리 환경 (Batch, 1950)
- 고가의 메인프레임
- 하나의 프로세스만 처리 가능
- 오퍼레이터가 일괄적으로 하나씩 실행
- 언어 : FORTRAN, ALGOL, LISP

#### 대화형 환경 (time-sharing, 1960)
- 정해진 시간 동안만 해당 프로세스 처리 후 다음으로 넘어감
- 하나씩 순회하면서 조금씩 처리
- 예를 들어 7개의 프로세스가 1초씩 분할해서 처리한다면, 1번 프로세스는 1초간 처리 후 7초 후에 다시 1초간 처리
- 언어 : COBOL, PL/I, APL, BASIC

#### PC의 등장 (1970)
- 미니 컴퓨터, 마이크로 컴퓨터의 등장
- 애플2, 매킨토시 등
- 언어 : Pascal, C, Smalltalk

#### PC의 보편화 (1980)

#### 클라이언트-서버 컴퓨팅 (1990)

#### 임베디드, 클라우드 등 분산처리 (2000)

<br/><br/><br/>

## 좋은 언어의 조건
베스트셀러가 좋은 책은 아닙니다. 성공한 언어란 외부적 영향을 많이 받게 되고, 결국 프로그래머의 선택에 의해 좌우됩니다.

### 명료성(clarity), 간결성(simplicity), 일관성(unity)
- 간단하고 명확해야 배우기 쉽습니다.
- 배우기 쉽다 = 코딩하기 쉽다. 하지만 너무 간단하면 write 관점에서는 좋으나 read 관점에서는 안좋을 수 있습니다.

### 직교성 (Orthogonality)
- 다른 기능을 임의로 조합할 수 있는 것
- 기능들의 독립성이 보장되어 있다는 의미입니다.
- 즉 한 요소의 변화가 다른 요소에 영향을 미치지 않는 것입니다.

### 자연스러운 응용 분야 지원
- 필요한 것을 바로 지원하고, 없으면 만들 수 있도록 하는 것입니다.
- 예를 들어 c언어는 boolean, string을 지원하지 않습니다. 다른 방법들로 해결은 가능하나, 자연스럽지 않습니다.

### 추상화 지원 (Abstraction)
- 복잡한 시스템을 단순화하여 다루기 쉽도록 만드는 것
- 대표적으로 클래스가 있습니다.

### 프로그램 테스트의 용이성
- 검증 : 가능할까???
- 테스트 : Desk Checking, Field Test

### 프로그래밍 환경
- 잘 정리된 문서, 개발 환경, 테스트 도구

### 프로그램 이식성
- 지원하는 플랫폼이 다양한가

### 비용
- (작성 + 컴파일 + 실행 + 테스트) 에다가 언어 배우기 등 모든 비용을 포함합니다.

<br/><br/><br/>

## 프로그래밍 패러다임
패러다임이란, 한 시대를 지배한는 총체적인 틀 또는 개념으로, 프로그래밍 패러다임이란 a general model for problem solving 즉 문제를 푸는 모델입니다.

### 프로그래밍 패러다임과 계산 모델
- 언어가 지원하는 패러다임과 계산 모델은 밀접한 관련이 있지만, 정확히 일대일 대응 관계는 아닙니다.
- 객체지향 패러다임은 명령형 언어로 지원하는 것이 대부분이지만, 함수형 언어로 지원할 수도 있습니다.

> 명령형 언어 : von Neumann Model
> 함수형 언어 : Recursive Function Model
> 논리언어 : Deductive Reasoning Model

이 있습니다.

### 명령형 언어
Imperative, Procedural Languages
- 상태전이 기계 (State Transition Machine)
- 상태를 변경하는 명령문 중심의 언어입니다.
- 폰노이만 아키텍쳐 구조 중심입니다.
- assignment가 많이 발생합니다.
- 구문이 실행될 때 마다 계속 상태가 변경됩니다.
- 언어 : FORTRAN, COBOL, C, Pascal

### 함수형 언어
Functional Languages, Applicative Languages
- 입력 값을 받아서 출력 값을 내는 함수
- 출력 값은 입력 값과 아무 연관성이 없습니다.
- 변수도 없고 대입 연산 (assignment)도 없습니다.
- 함수 합성이 주요 수단입니다.
- 자기 자신을 합성 (재귀) 도 가능합니다.
- 언어 : LISP, Scheme, ML, Haskell

### 규칙기반 언어
Rule-Based Languages, Logic Languages
- 논리 규칙에 입각한 추론
- 입력 = 명제의 조합
- 출력 = 추론 결과로 얻은 명제 또는 명제의 일부
- 문제의 여러 특성을 논리 규칙으로 설정하는 것이 주요 프로그래밍 작업입니다.
- 언어 : Prolog

### 객체지향 언어
Object-Oriented Languages
- 특정 계산 모델을 가정하고 있지 않지만, 주로 명령형 패러다임의 언어에 의해 구현됩니다.
- 객체들로 프로그램을 구성합니다.
- 속성은 데이터로 구현되고 행태는 메소드로 구현됩니다.
- 언어 : Smalltalk, C++, Java

<br/><br/><br/>

## 구조화 프로그래밍
### 출현 배경
- write보다 read관점, 즉 유지보수성에 초점이 가면서 등장함
- GO TO 논란 (프로그램의 흐름 구조를 이해하기 어려움)

### 이론적 기반
- 모든 흐름 제어 구조는 다음 3가지 구조로 표현 가능
1. 순차 구조
2. 선택 구조
3. 반복 구조
- 하향식 설계 방법 : 큰 문제를 작은 문제들로 쪼개서 각각을 해결하고 이를 결합하여 전체 문제르르 해결. 모듈화 사용
- 프라임 프로그램 : 프로그램의 시작과 끝은 오직 하나만 존재

<br/><br/><br/>

## 언어 표준화의 배경
```i = 1 && 2 + 3 | 4;``` 라는 구문이 있다면, i에 저장되는 값은?
- 방법 1) 언어 매뉴얼을 본다
- 방법 2) 언어 표준을 본다
- 방법 3) 프로그램을 작성한 후 실행 결과를 본다
- 대부분 3번을 선택하지만, 이것만으로는 확신할 수 없다.

<br/><br/><br/>

## 언어 표준과 언어 구현
- 언어 표준 : 문서 (= 언어 설계도)
- 언어 구현 : 컴파일러, 인터프리터
- 같은 언어 표준을 기반으로 구현하면 다 똑같아야 하지만, 사실은 그렇지 않습니다. 구현 1과 구현 N의 교집합이 언어 표준입니다.

### 표준화 기구
- ISO : International Standards Organizations
- IEEE : Institute of Elecctrical and Electronics Engineers
- ANSI : American National Standards Institute

### 담당 업무
- 표준을 정의할 워킹그룹 결성
- 새로운 표준안에 포함될 기능들 제시
- 표준안에 대한 투표
- 통과된 표준안을 상위 기구에 상정
- 표준안 공표 및 새로운 표준안 검토 (약 5~10년 주기로 검토)

### 언어 표준화 시기
- 너무 늦으면 : 너무 많은 구현(버전)이 존재
- 너무 빠르면 : 구현된 것이 별로 없어 경험 축적 불가
- 적절히 : 베스트지만 그런 예가 별로 없음

<br/><br/><br/>

## 국제화
### 언어의 국제화
- I18N이라고도 합니다. : internationalization, internationalisation
- 전세계적으로 유용하게 사용할 수 있는 언어 정의 방법을 고려함

### 관련 주제들
- 문자 : 7-bit ASCII -> 16-bit Unicode
- 코드에서 문자들의 나열 순서
- 날짜, 시간, 통화 단위 등등등

<br/><br/><br/>

## 프로그래밍 환경
- 프로그램 작성, 테스트에 사용되는 환경
- 프로그램 수행 환경과는 구별됨
- 프로그래밍 언어의 사용층에 지대한 영향을 미침
- 프로그래밍 언어 설계에서 영향을 미치기도 함 (분리 컴파일, 데스트 및 디버깅)

### 분리 컴파일
#### 공유되어야 하는 정보
- 서브 프로그램 호출 정보
- 공유되는 변수 타입
- 공동으로 사용해야 할 타입의 정의

#### 분리 컴파일을 지원하는 방법
- Option 1 : 필요한 것을 다시 선언
- Option 2 : 특정 순서로 컴파일되도록 함(specification이 먼저 오도록)
- Option 3 : 관련 정보를 라이브러리 형태로 참조할 수 있도록 함

#### 용어 구분
- 분리 컴파일 (separate compilation) : 인터페이스 정보를 필요로 할 수 있음
- 독립 컴파일 (independent compilation) : 각 컴파일 단위가 독립적 = Option 1

### 테스트 및 디버깅 지원 방법
- 실행 순서 따라가기 (execution trace) : Prolog, LISP 등 대화형 언어
- 중단점 설정 (breakpoints) : 명령형 언어
- 조건 검사 (assertion) : 프로그램 수행 도중 만족해야 할 조건 검사. 배포 버전에서는 제거될 수 있도록 설계됨## 프로그래밍 언어의 역할
- 사람과 기계와의 의사소통 : 알고리즘이나 자료 구조를 표현하는 방법 = 프로그래밍 언어
- 사람과 사람과의 의사사통을 위한 매개체 역할

<br/><br/><br/>

## 읽기와 쓰기
#### 프로그래밍 숙련도
- 프로그래밍은 ‘쓰기’가 강조되는 분야
- ‘읽기’도 무시 불가. 이해하기 쉽게 코드를 작성해야 좋은 개발자이다.

#### 가독성(readability)의 중요성
- “read easily and understood by people"

<br/><br/><br/>

## 프로그래밍 언어를 학습하는 이유
1. 효과적인 알고리즘 개발
2. 더 잘 이해하여 효과적 사용
 언어에 대한 이해도가 높아져 프로그램 작성 능력 증가
 예를 들어 ```i = i + 1``` / ```i++``` 둘 다 같은 기능을 하지만 후자가 더 빠름
3. 유용한 프로그래밍 요소 활용 가능
4. 프로그램 특성에 맞는 언어 선택
5. 새로운 언어를 쉽게 배우기 위해
 프로그래밍 언어들은 많은 유사점 존재
6. 새로운 언어를 쉽게 설계하기 위해

<br/><br/><br/>

## 프로그래밍 언어의 분류
### 문제 영역 (Problem Domain)
- 사무용, 과학계산, 시스템 프로그래밍, 인공지능, 웹과 같이 분야에 따라 나누기

### 패러다임
패러다임 = 프로그래밍 스타일 이다.
- 절차 언어
- 함수형 언어
- 모듈 기반 언어
- 객체 지향 언어
- generic 프로그래밍
- 룰 기반 언어

### 계산 모델 (Computational Model)
- 명령형 언어 : 폰 노이만 구조 기반
- 함수형 언어 : 순환 함수 이론 기반
- 논리 언어 : 수학적 논리(연역 논리) 기반

<br/><br/><br/>

## 프로그래밍 언어의 목표 변천사
초창기기인 1950~60년대는 언어와 하드웨어 밀착 시기여서 goto문을 사용하고 컴퓨터 값이 고가이므로 수행 효율이 매우 중요했습니다.

#### 일괄처리 환경 (Batch, 1950)
- 고가의 메인프레임
- 하나의 프로세스만 처리 가능
- 오퍼레이터가 일괄적으로 하나씩 실행
- 언어 : FORTRAN, ALGOL, LISP

#### 대화형 환경 (time-sharing, 1960)
- 정해진 시간 동안만 해당 프로세스 처리 후 다음으로 넘어감
- 하나씩 순회하면서 조금씩 처리
- 예를 들어 7개의 프로세스가 1초씩 분할해서 처리한다면, 1번 프로세스는 1초간 처리 후 7초 후에 다시 1초간 처리
- 언어 : COBOL, PL/I, APL, BASIC

#### PC의 등장 (1970)
- 미니 컴퓨터, 마이크로 컴퓨터의 등장
- 애플2, 매킨토시 등
- 언어 : Pascal, C, Smalltalk

#### PC의 보편화 (1980)

#### 클라이언트-서버 컴퓨팅 (1990)

#### 임베디드, 클라우드 등 분산처리 (2000)

<br/><br/><br/>

## 좋은 언어의 조건
베스트셀러가 좋은 책은 아닙니다. 성공한 언어란 외부적 영향을 많이 받게 되고, 결국 프로그래머의 선택에 의해 좌우됩니다.

### 명료성(clarity), 간결성(simplicity), 일관성(unity)
- 간단하고 명확해야 배우기 쉽습니다.
- 배우기 쉽다 = 코딩하기 쉽다. 하지만 너무 간단하면 write 관점에서는 좋으나 read 관점에서는 안좋을 수 있습니다.

### 직교성 (Orthogonality)
- 다른 기능을 임의로 조합할 수 있는 것
- 기능들의 독립성이 보장되어 있다는 의미입니다.
- 즉 한 요소의 변화가 다른 요소에 영향을 미치지 않는 것입니다.

### 자연스러운 응용 분야 지원
- 필요한 것을 바로 지원하고, 없으면 만들 수 있도록 하는 것입니다.
- 예를 들어 c언어는 boolean, string을 지원하지 않습니다. 다른 방법들로 해결은 가능하나, 자연스럽지 않습니다.

### 추상화 지원 (Abstraction)
- 복잡한 시스템을 단순화하여 다루기 쉽도록 만드는 것
- 대표적으로 클래스가 있습니다.

### 프로그램 테스트의 용이성
- 검증 : 가능할까???
- 테스트 : Desk Checking, Field Test

### 프로그래밍 환경
- 잘 정리된 문서, 개발 환경, 테스트 도구

### 프로그램 이식성
- 지원하는 플랫폼이 다양한가

### 비용
- (작성 + 컴파일 + 실행 + 테스트) 에다가 언어 배우기 등 모든 비용을 포함합니다.

<br/><br/><br/>

## 프로그래밍 패러다임
패러다임이란, 한 시대를 지배한는 총체적인 틀 또는 개념으로, 프로그래밍 패러다임이란 a general model for problem solving 즉 문제를 푸는 모델입니다.

### 프로그래밍 패러다임과 계산 모델
- 언어가 지원하는 패러다임과 계산 모델은 밀접한 관련이 있지만, 정확히 일대일 대응 관계는 아닙니다.
- 객체지향 패러다임은 명령형 언어로 지원하는 것이 대부분이지만, 함수형 언어로 지원할 수도 있습니다.

> 명령형 언어 : von Neumann Model
> 함수형 언어 : Recursive Function Model
> 논리언어 : Deductive Reasoning Model

이 있습니다.

### 명령형 언어
Imperative, Procedural Languages
- 상태전이 기계 (State Transition Machine)
- 상태를 변경하는 명령문 중심의 언어입니다.
- 폰노이만 아키텍쳐 구조 중심입니다.
- assignment가 많이 발생합니다.
- 구문이 실행될 때 마다 계속 상태가 변경됩니다.
- 언어 : FORTRAN, COBOL, C, Pascal

### 함수형 언어
Functional Languages, Applicative Languages
- 입력 값을 받아서 출력 값을 내는 함수
- 출력 값은 입력 값과 아무 연관성이 없습니다.
- 변수도 없고 대입 연산 (assignment)도 없습니다.
- 함수 합성이 주요 수단입니다.
- 자기 자신을 합성 (재귀) 도 가능합니다.
- 언어 : LISP, Scheme, ML, Haskell

### 규칙기반 언어
Rule-Based Languages, Logic Languages
- 논리 규칙에 입각한 추론
- 입력 = 명제의 조합
- 출력 = 추론 결과로 얻은 명제 또는 명제의 일부
- 문제의 여러 특성을 논리 규칙으로 설정하는 것이 주요 프로그래밍 작업입니다.
- 언어 : Prolog

### 객체지향 언어
Object-Oriented Languages
- 특정 계산 모델을 가정하고 있지 않지만, 주로 명령형 패러다임의 언어에 의해 구현됩니다.
- 객체들로 프로그램을 구성합니다.
- 속성은 데이터로 구현되고 행태는 메소드로 구현됩니다.
- 언어 : Smalltalk, C++, Java

<br/><br/><br/>

## 구조화 프로그래밍
### 출현 배경
- write보다 read관점, 즉 유지보수성에 초점이 가면서 등장함
- GO TO 논란 (프로그램의 흐름 구조를 이해하기 어려움)

### 이론적 기반
- 모든 흐름 제어 구조는 다음 3가지 구조로 표현 가능
1. 순차 구조
2. 선택 구조
3. 반복 구조
- 하향식 설계 방법 : 큰 문제를 작은 문제들로 쪼개서 각각을 해결하고 이를 결합하여 전체 문제르르 해결. 모듈화 사용
- 프라임 프로그램 : 프로그램의 시작과 끝은 오직 하나만 존재

<br/><br/><br/>

## 언어 표준화의 배경
```i = 1 && 2 + 3 | 4;``` 라는 구문이 있다면, i에 저장되는 값은?
- 방법 1) 언어 매뉴얼을 본다
- 방법 2) 언어 표준을 본다
- 방법 3) 프로그램을 작성한 후 실행 결과를 본다
- 대부분 3번을 선택하지만, 이것만으로는 확신할 수 없다.

<br/><br/><br/>

## 언어 표준과 언어 구현
- 언어 표준 : 문서 (= 언어 설계도)
- 언어 구현 : 컴파일러, 인터프리터
- 같은 언어 표준을 기반으로 구현하면 다 똑같아야 하지만, 사실은 그렇지 않습니다. 구현 1과 구현 N의 교집합이 언어 표준입니다.

### 표준화 기구
- ISO : International Standards Organizations
- IEEE : Institute of Elecctrical and Electronics Engineers
- ANSI : American National Standards Institute

### 담당 업무
- 표준을 정의할 워킹그룹 결성
- 새로운 표준안에 포함될 기능들 제시
- 표준안에 대한 투표
- 통과된 표준안을 상위 기구에 상정
- 표준안 공표 및 새로운 표준안 검토 (약 5~10년 주기로 검토)

### 언어 표준화 시기
- 너무 늦으면 : 너무 많은 구현(버전)이 존재
- 너무 빠르면 : 구현된 것이 별로 없어 경험 축적 불가
- 적절히 : 베스트지만 그런 예가 별로 없음

<br/><br/><br/>

## 국제화
### 언어의 국제화
- I18N이라고도 합니다. : internationalization, internationalisation
- 전세계적으로 유용하게 사용할 수 있는 언어 정의 방법을 고려함

### 관련 주제들
- 문자 : 7-bit ASCII -> 16-bit Unicode
- 코드에서 문자들의 나열 순서
- 날짜, 시간, 통화 단위 등등등

<br/><br/><br/>

## 프로그래밍 환경
- 프로그램 작성, 테스트에 사용되는 환경
- 프로그램 수행 환경과는 구별됨
- 프로그래밍 언어의 사용층에 지대한 영향을 미침
- 프로그래밍 언어 설계에서 영향을 미치기도 함 (분리 컴파일, 데스트 및 디버깅)

### 분리 컴파일
#### 공유되어야 하는 정보
- 서브 프로그램 호출 정보
- 공유되는 변수 타입
- 공동으로 사용해야 할 타입의 정의

#### 분리 컴파일을 지원하는 방법
- Option 1 : 필요한 것을 다시 선언
- Option 2 : 특정 순서로 컴파일되도록 함(specification이 먼저 오도록)
- Option 3 : 관련 정보를 라이브러리 형태로 참조할 수 있도록 함

#### 용어 구분
- 분리 컴파일 (separate compilation) : 인터페이스 정보를 필요로 할 수 있음
- 독립 컴파일 (independent compilation) : 각 컴파일 단위가 독립적 = Option 1

### 테스트 및 디버깅 지원 방법
- 실행 순서 따라가기 (execution trace) : Prolog, LISP 등 대화형 언어
- 중단점 설정 (breakpoints) : 명령형 언어
- 조건 검사 (assertion) : 프로그램 수행 도중 만족해야 할 조건 검사. 배포 버전에서는 제거될 수 있도록 설계됨