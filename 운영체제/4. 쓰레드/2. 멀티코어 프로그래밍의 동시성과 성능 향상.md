## 병렬성 vs 동시성
***병렬성(parallelism)*** 이란, 시스템에 둘 이상의 코어가 있어서 둘 이상의 테스크를 동시에 실행할 수 있는 환경을 말합니다. 실제로도 동시에 작업이 처리됩니다.

***동시성(concurrency)*** 이란, 둘 이상의 작업 수행을 지원하는데, 물리적으로 동시에 실행하는 것이 아니라 동시에 실행되는 것 처럼 보이게 하므로써 지원합니다.

두 작업의 차이점을 그림으로 나타내보면

![](https://velog.velcdn.com/images/seokjun0915/post/e92f12b5-8389-43c1-900f-3a45e4d516ad/image.jpeg)

- ***Concurrency***입장에서는, 하나의 싱글코어로 여러 작업을 계속해서 전환하면서 동시에 실행되는 것처럼 보이게끔 합니다.

- ***Prallelism*** 입장에서는 여러개의 코어가 일을 분할하여 물리적으로도 동시에 실행합니다. 하지만 데이터 일관성 문제, 캐시 공유 등 매우 어렵습니다.


### Parallelism의 타입(= 전략)
- Data parallelism
동일한 데이터의 하위 집합을 여러 코어에 분산시켜 각 코어에서 동일한 작업을 수행합니다.


- Task parallelism
코어에 스레드를 분산시켜 각 스레드는 고유한 작업을 수행합니다. 이 방법이 설계가 매우매우매우 어렵습니다.

그림으로 차이점을 살펴보면

![](https://velog.velcdn.com/images/seokjun0915/post/9fb43587-becf-4bb2-8931-e606e723d4d0/image.jpeg)

- ***Data parallelism*** 의 입장에서는 데이터 자체를 나누고 각 코어에 할당합니다. 이 경우에는 각 코어가 데이터를 공유하지 않습니다.

- ***Task parallelism*** 의 입장에서는 동일한 하나의 데이터를 각 코어가 동시에 접근하여 사용합니다. 이때는 각 코어들이 같은 데이터를 공유하고 있기 때문에 데이터 동시성 문제 등이 발생하기 때문에 설계가 어렵습니다.

<br/><br/><br/>

## Amdahl's Law
코어수가 늘어난다고 무조건적으로 성능이 증가하는 것은 아닙니다. 어플리케이션은 serial + parallel 부분들로 구성되어 있을 때, 코어를 추가하여 얻을 수 있는 성능 향상치를 말합니다.

> $speed-up <= \frac 1 {S + \frac {1 - S} N}$

성능은 시간의 역수로 구할 수 있습니다. 시간을 구해보면, 총 시간은 $단일 작업 시간 + 병렬 작업 시간$ 으로 구할 수 있습니다. 즉

> $time = serial + \frac {1 - serial} {number of core}$

로 구할 수 있습니다. serial 수치는 비율로 주어집니다. 1에서 serial 작업을 빼면 멀티 작업의 비율이 나오고 이를 코어수로 나누면 최종 시간을 구할 수 있습니다. 예를 들어, 75% parallel, 25% serial 구간이고 코어 수를 2개로 늘린다면, 속도 향상은 1.6배 빨라집니다. 

코어수가 무한히 늘어난다고 한다면, 시간은 $\frac 1 {serial}$ 로 수렴합니다. 즉, serial 실행 구간은 코어 추가로 인한 성능 향상 이득을 제한합니다.## 병렬성 vs 동시성
***병렬성(parallelism)*** 이란, 시스템에 둘 이상의 코어가 있어서 둘 이상의 테스크를 동시에 실행할 수 있는 환경을 말합니다. 실제로도 동시에 작업이 처리됩니다.

***동시성(concurrency)*** 이란, 둘 이상의 작업 수행을 지원하는데, 물리적으로 동시에 실행하는 것이 아니라 동시에 실행되는 것 처럼 보이게 하므로써 지원합니다.

두 작업의 차이점을 그림으로 나타내보면

![](https://velog.velcdn.com/images/seokjun0915/post/e92f12b5-8389-43c1-900f-3a45e4d516ad/image.jpeg)

- ***Concurrency***입장에서는, 하나의 싱글코어로 여러 작업을 계속해서 전환하면서 동시에 실행되는 것처럼 보이게끔 합니다.

- ***Prallelism*** 입장에서는 여러개의 코어가 일을 분할하여 물리적으로도 동시에 실행합니다. 하지만 데이터 일관성 문제, 캐시 공유 등 매우 어렵습니다.


### Parallelism의 타입(= 전략)
- Data parallelism
동일한 데이터의 하위 집합을 여러 코어에 분산시켜 각 코어에서 동일한 작업을 수행합니다.


- Task parallelism
코어에 스레드를 분산시켜 각 스레드는 고유한 작업을 수행합니다. 이 방법이 설계가 매우매우매우 어렵습니다.

그림으로 차이점을 살펴보면

![](https://velog.velcdn.com/images/seokjun0915/post/9fb43587-becf-4bb2-8931-e606e723d4d0/image.jpeg)

- ***Data parallelism*** 의 입장에서는 데이터 자체를 나누고 각 코어에 할당합니다. 이 경우에는 각 코어가 데이터를 공유하지 않습니다.

- ***Task parallelism*** 의 입장에서는 동일한 하나의 데이터를 각 코어가 동시에 접근하여 사용합니다. 이때는 각 코어들이 같은 데이터를 공유하고 있기 때문에 데이터 동시성 문제 등이 발생하기 때문에 설계가 어렵습니다.

<br/><br/><br/>

## Amdahl's Law
코어수가 늘어난다고 무조건적으로 성능이 증가하는 것은 아닙니다. 어플리케이션은 serial + parallel 부분들로 구성되어 있을 때, 코어를 추가하여 얻을 수 있는 성능 향상치를 말합니다.

> $speed-up <= \frac 1 {S + \frac {1 - S} N}$

성능은 시간의 역수로 구할 수 있습니다. 시간을 구해보면, 총 시간은 $단일 작업 시간 + 병렬 작업 시간$ 으로 구할 수 있습니다. 즉

> $time = serial + \frac {1 - serial} {\#core}$

로 구할 수 있습니다. serial 수치는 비율로 주어집니다. 1에서 serial 작업을 빼면 멀티 작업의 비율이 나오고 이를 코어수로 나누면 최종 시간을 구할 수 있습니다. 예를 들어, 75% parallel, 25% serial 구간이고 코어 수를 2개로 늘린다면, 속도 향상은 1.6배 빨라집니다. 

코어수가 무한히 늘어난다고 한다면, 시간은 $\frac 1 {serial}$ 로 수렴합니다. 즉, serial 실행 구간은 코어 추가로 인한 성능 향상 이득을 제한합니다.
