## Thread
최근의 대부분의 어플리케이션은 Multi-THreaded 입니다. 그럼 쓰레드란 ?!

> ***한 프로세스에 속하면서 별도의 실행 흐름을 가질 수 있는 것***

이라고 할 수 있습니다. 하나의 프로세스는 여러 개의 실행 흐름을 가질 수 있습니다. 하나의 어플리케이션 하위에는 여러 개의 프로세스가 존재하고, 하나의 프로세스 하위에는 여러 개의 쓰레드가 존재합니다.

- 프로세스 생성은 무겁습니다. 반면, 쓰레드 생성은 보다 가볍습니다. 프로세스 생성 시에는 메모리 공간 할당, 코드 불러오기, 스케쥴 관리 등 해야할 작업이 많은 반면, 쓰레드는 레지스터 상태, stack, program counter 만 저장하면 됩니다. 

- 쓰레드는 단순 반복작업에 주로 쓰입니다. 코드를 단순화 할 수 있고, 효율이 좋습니다.

- 쓰레드는 부모 프로세스의 code, data, file 을 공유합니다. 따라서 전역 변수를 공유할 수 있습니다. 

![](https://velog.velcdn.com/images/seokjun0915/post/5e8e18d1-a8ba-4519-96d4-fd20bd64814a/image.jpeg)

### Multi-Threaded 서버 아키텍쳐
쓰레드는 서버에서 아주  유용하게 쓰입니다. 서버는 클라이언트 별로 전용 쓰레드를 생성하여 각 쓰레드가 클라이언트의 요청을 처리합니다.

![](https://velog.velcdn.com/images/seokjun0915/post/9140c5d9-b7ee-4454-8461-5c1e7dfdf32f/image.jpeg)

위 아키텍쳐의 메모리 구성을 살펴보면

![](https://velog.velcdn.com/images/seokjun0915/post/57a61f41-49c8-4016-9598-62c52033fc71/image.jpeg)

스택 영역만 쓰레드 별로 할당해주면 끝납니다! 그래서 멀티 프로세스 환경보다 자원이 덜 들어갑니다.

### 멀티-쓰레드의 장점
1. UI 응답성 향상
UI 대부분은 대기 상태입니다. 하나의 실행 흐름으로 가면, blocking이 발생되면 응답이 있을 때까지 대기라 멈춘 상태가 되어버립니다.

2. 자원 공유가 쉽다!
프로세스의 data 부분이 공유 영역에 있기 때문에 메인 쓰레드와 그 외에 한 프로세스에 속한 쓰레드들 사이의 전역 변수 접근이 가능합니다. 

3. 싸다!
프로세스보다 경제적입니다. 즉, 자원 소모가 덜합니다. context-switching이 thread-switching 보다 overhead가 더 많습니다. 

4. 확장성 좋다
멀티코어 아키텍쳐이기 때문에 확장성이 좋습니다.



## 멀티코어 프로그래밍
### 멀티코어 vs 멀티프로세서
두 개념은 다릅니다!!!

- CPU가 여러개 = 멀티-프로세서
- 하나의 칩에 여러 코어가 들어있는 것 = 멀티-코어

최근에는 대부분이 멀티코어 형태입니다. 하나의 코어는 보통 하나의 일을 하고 (아키텍쳐의 발전으로 2개도 가능) 하나의 일이란, 하나의 쓰레드를 말합니다. 

하나의 코어에서 여러 개의 쓰레드를 실행하는 것을 SMT(Simultaneous MT or Hyper threading) 이라고도 합니다.

하지만 !!!!!!! 멀티 코어가 좋아도, 결국 주로 일하는 코어는 하나입니다. 윈도우 작업관리자에 들어가서 CPU 사용량을 보면, 대부분 첫번째 코어만 클럭이 높고 나머지 코어들은 대부분이 놀고있는 것을 알 수 있습니다.

### 멀티코어 프로그래밍 과정
코어에 적절히 작업을 분배하는 프로그래밍입니다. 소프트웨어 아키텍쳐의 영역이라고 볼 수 있습니다.

1. Identifying tasks
어플리케이션을 컴토하여 동시에 수행될 수 있는 부분으로 나눌 수 있는 영역 찾고 이렇게 나누어진 작업들은 서로 독립적이므로 개별 코어에서 병렬로 실행됩니다.


2. Balance
나눠진 작업은 동일한 가치의 작업인지 (자원을 적절히 나누어 쓰는지), 별도의 코어를 사용할 가치가 있는 작업인지 확인합니다.


3. Data splitting
데이터를 잘 나누자!


4. Data dependency
데이터를 나누는 경우, 데이터 종속성 확인이 필요합니다.


5. 테스팅 및 디버깅!


